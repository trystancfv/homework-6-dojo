#!/opt/pwn.college/python

import unittest
import sys
from datetime import datetime, timezone, timedelta

sys.path.append("/challenge")

import auth_service

TEST_USERS = [
    {
        'username': 'john',
        'email': 'john@gmail.com',
        'password': 'j0hn_pw'
    },
    {
        'username': 'mickey',
        'email': 'mickeymouse@disney.com',
        'password': 'hiyapal'
    }
]

class TestAuthService(unittest.TestCase):
    def setUp(self):
        # Clear in-memory "database" before each test.
        auth_service.USERS.clear()
        auth_service.RESET_TOKENS.clear()
        auth_service.initialize_data(TEST_USERS)

    def _run_and_compile_logs(self, func, *args, **kwargs):
        logger_name = 'auth_logger'
        with self.assertLogs(logger_name, level='INFO') as cm:
            result = func(*args, **kwargs)
        logs= "\n".join(cm.output)
        
        return result, logs
    
    # Login Behavior Tests:

    def test_login_success_returns_session_with_no_secrets_in_logs(self):
        username = 'john'
        password = 'j0hn_pw'
        ip = '198.51.100.50'

        result, logs = self._run_and_compile_logs(auth_service.login, username, password, ip)

        # Function tests.
        self.assertIsNotNone(result)
        self.assertEqual(result['username'], username)
        self.assertIn('session_id', result)
        session_id = result['session_id']
        self.assertIsInstance(session_id, str)

        # Tests logging of attempt and success by specific user.
        self.assertIn('Login attempt', logs)
        self.assertIn('Login success', logs)
        self.assertIn(username, logs)
        self.assertIn(ip, logs)

        # Tests sensitive information is not contained in the logs.
        self.assertNotIn(password, logs)
        self.assertNotIn(session_id, logs)

    def test_login_with_incorrect_password_increments_attempts_with_no_logged_password(self):
        username = 'john'
        wrong_password = 'wrong_pw'
        ip = '198.51.100.55'

        before_attempts_count = auth_service.USERS[username]['failed_attempts']
        result, logs = self._run_and_compile_logs(auth_service.login, username, wrong_password, ip)
        after_attempts_count = auth_service.USERS[username]['failed_attempts']

        # Function tests.
        self.assertIsNone(result)
        self.assertEqual(after_attempts_count, before_attempts_count + 1)

        # Tests logging of failure and user, but not password.
        self.assertIn('Login failed', logs)
        self.assertIn(username, logs)
        self.assertIn(ip, logs)
        self.assertNotIn(wrong_password, logs)

    def test_login_locks_out_after_three_failures_and_locked_message_logs(self):
        username = 'john'
        wrong_password = 'wrong_pw'
        ip = '198.51.100.60'

        for _ in range(3):
            auth_service.login(username, wrong_password, ip)

        self.assertTrue(auth_service.USERS[username]['is_locked'])

        correct_password = 'j0hn_pw'
        result, logs = self._run_and_compile_logs(auth_service.login, username, correct_password, ip)

        # Tests for failure of subsequent login.
        # Function tests.
        self.assertIsNone(result)
        self.assertIn('locked account', logs)
        self.assertIn(username, logs)
        self.assertIn(ip, logs)

        # Tests that no password logged.
        self.assertNotIn(correct_password, logs)
        self.assertNotIn(wrong_password, logs)

    def test_login_as_unknown_user_has_no_password_leaks(self):
        username = 'Unknown'
        password = 'random_pw'
        ip = '198.51.100.65'

        result, logs = self._run_and_compile_logs(auth_service.login, username, password, ip)

        # Function tests.
        self.assertIsNone(result)
        self.assertIn('unknown user', logs)
        self.assertIn(username, logs)
        self.assertIn(ip, logs)

        # Tests that password does not appear.
        self.assertNotIn(password, logs)
        
    # Password Reset Request Behavior Tests:

    def test_password_reset_for_existing_email_stores_token_with_no_secrets_in_logs(self):
        email = 'mickeymouse@disney.com'

        token, logs = self._run_and_compile_logs(auth_service.request_password_reset, email)

        # Function tests.
        self.assertIsInstance(token, str)
        self.assertIn(token, auth_service.RESET_TOKENS)
        token_data = auth_service.RESET_TOKENS[token]
        self.assertEqual(token_data['username'], 'mickey')
         
        # Tests logging indicates reset request and token generated.
        self.assertIn('Password reset requested', logs)
        self.assertIn('Generated password reset token', logs)

        # Tests that full email or token does not appear.
        self.assertNotIn(email, logs)
        self.assertNotIn(token, logs)

    def test_password_reset_for_nonexistent_email_returns_none_and_no_full_email_in_logs(self):
        email = 'nonexistent@example.com'

        token, logs = self._run_and_compile_logs(auth_service.request_password_reset, email)

        # Function test.
        self.assertIsNone(token)
        self.assertIn('Password reset email not found', logs)
        
        # Tests that full email does not appear.
        self.assertNotIn(email, logs)

    # Reset Password Behavior Tests:

    def test_reset_password_success_changes_password_and_no_secrets_in_logs(self):
        email = 'john@gmail.com'

        token = auth_service.request_password_reset(email)
        self.assertIsNotNone(token)
        new_password = 'j0hns_new_pw'

        result, logs = self._run_and_compile_logs(auth_service.reset_password, token, new_password)

        # Functional tests.
        self.assertTrue(result)
        user = auth_service.find_user_by_username('john')
        self.assertIsNotNone(user)
        self.assertEqual(user['password'], new_password)
        self.assertNotIn(token, auth_service.RESET_TOKENS)

        # Tests logs mention success and username, but not password or tokens.
        self.assertIn('Password reset success', logs)
        self.assertIn('john', logs)
        self.assertNotIn(new_password, logs)
        self.assertNotIn(token, logs)
    
    def test_reset_password_with_invalid_token_fails_and_no_secrets_in_logs(self):
        invalid_token = 'not-real-token'
        new_password = 'new_j0hn_pass'

        result, logs = self._run_and_compile_logs(auth_service.reset_password, invalid_token, new_password)

        # Function tests.
        self.assertFalse(result)
        self.assertIn('Password reset failed', logs)
        self.assertIn('invalid token', logs)
        
        # Tests that token and password do not appear.
        self.assertNotIn(invalid_token, logs)
        self.assertNotIn(new_password, logs)

    def test_reset_password_with_expired_token_fails_and_no_secrets_in_logs(self):
        email = 'john@gmail.com'
        token = auth_service.request_password_reset(email)
        self.assertIsNotNone(token)

        # Forces the token to expire.
        auth_service.RESET_TOKENS[token]['created_at'] = datetime.now(timezone.utc) - timedelta(minutes=60)

        new_password = 'j0hn_new_pw'
        result, logs = self._run_and_compile_logs(auth_service.reset_password, token, new_password)

        # Function tests.
        self.assertFalse(result)
        self.assertIn('Password reset failed', logs)
        self.assertIn('expired token', logs)
        self.assertNotIn(token, auth_service.RESET_TOKENS)

        # Tests that token and password do not appear.
        self.assertNotIn(token, logs)
        self.assertNotIn(new_password, logs)

    def test_password_reset_with_missing_user_fails_and_no_secrets_in_logs(self):
        email = 'john@gmail.com'
        token = auth_service.request_password_reset(email)
        self.assertIsNotNone(token)

        # Removes the user to simulate a missing situation.
        username = auth_service.RESET_TOKENS[token]['username']
        auth_service.USERS.pop(username, None)

        new_password = 'j0hn_new_pw'
        result, logs = self._run_and_compile_logs(auth_service.reset_password, token, new_password)
        
        # Function tests.
        self.assertFalse(result)
        self.assertIn('Password reset failed', logs)
        self.assertIn('references nonexistent user', logs)
        self.assertNotIn(token, auth_service.RESET_TOKENS)

        # Tests that token and password do not appear.
        self.assertNotIn(token, logs)
        self.assertNotIn(new_password, logs)

    # Sanity check tests:

    def test_logging_still_exists(self):
        email = 'john@gmail.com'
        result_reset, logs_reset = self._run_and_compile_logs(auth_service.request_password_reset, email)
        self.assertTrue(len(logs_reset) > 0)
        self.assertIn('Password reset', logs_reset)

        result_login, logs_login = self._run_and_compile_logs(auth_service.login, 'john', 'j0hn_pw', '203.0.111.99')
        self.assertIsNotNone(result_login)
        self.assertTrue(len(logs_login) > 0)
        self.assertIn('Login', logs_login)

    # ChatGPT Generated Test Cases:

    def test_no_user_secrets_appear_in_logs_across_common_flows(self):
        """
        End-to-end sanity: across a typical sequence of operations, no full
        emails, raw passwords, reset tokens, or session IDs should appear
        in any log output.
        """
        ip = '198.51.100.99'

        # 1. Failed login attempt.
        _, logs1 = self._run_and_compile_logs(auth_service.login, 'john', 'wrong_pw', ip)

        # 2. Successful login attempt.
        result_success, logs2 = self._run_and_compile_logs(auth_service.login, 'john', 'j0hn_pw', ip)
        self.assertIsNotNone(result_success)
        session_id = result_success['session_id']

        # 3. Password reset request for an existing email.
        email = 'john@gmail.com'
        token, logs3 = self._run_and_compile_logs(auth_service.request_password_reset, email)
        # token may be None if implementation changes, but in current design it should be a string.
        self.assertIsInstance(token, str)

        # 4. Password reset success path.
        new_password = 'totally_new_pw123'
        reset_result, logs4 = self._run_and_compile_logs(auth_service.reset_password, token, new_password)
        self.assertTrue(reset_result)

        # Combine logs from all these actions.
        all_logs = "\n".join([logs1, logs2, logs3, logs4])

        # No full emails or passwords from TEST_USERS should ever appear.
        for user in TEST_USERS:
            self.assertNotIn(user['email'], all_logs)
            self.assertNotIn(user['password'], all_logs)

        # The new password should not appear anywhere.
        self.assertNotIn(new_password, all_logs)

        # The full reset token and session ID should also not appear.
        self.assertNotIn(token, all_logs)
        self.assertNotIn(session_id, all_logs)

    def test_login_without_ip_address_logs_safely(self):
        """
        If ip_address is omitted, login should still work and logs should
        not contain passwords or session IDs.
        """
        username = 'john'
        password = 'j0hn_pw'

        result, logs = self._run_and_compile_logs(auth_service.login, username, password)

        # Functional behavior.
        self.assertIsNotNone(result)
        self.assertEqual(result['username'], username)
        session_id = result['session_id']

        # Logging behavior.
        self.assertIn('Login', logs)
        self.assertIn(username, logs)
        # No secrets:
        self.assertNotIn(password, logs)
        self.assertNotIn(session_id, logs)

    def test_system_logger_name_remains_auth_logger(self):
        """
        The challenge specifies that the logger name must remain 'auth_logger'.
        This test enforces that invariant.
        """
        self.assertEqual(auth_service.system_logger.name, 'auth_logger')


# Taken from https://stackoverflow.com/questions/13550039/how-to-use-python-unit-tests-in-self-contained-program
def run_tests(test_case):
    case = unittest.TestLoader().loadTestsFromTestCase(test_case)
    result = unittest.TestResult()
    case(result)
    if result.wasSuccessful():
        print("{0}/{0} tests passed!".format(result.testsRun))
        return True
    
    else:
        print("{0}/{1} tests failed!".format(len(result.failures), result.testsRun))
        for test, err in result.failures + result.errors:
            print("===================")
            print(test)
            print(err)
        
        print("===================")
        return False


if run_tests(TestAuthService):
    print("All tests pass! Reading and displaying flag...")
    with open("/flag") as f:
        print(f.read())
else:
    print("Some tests fail. Please review the test cases and errors, then try again.")
